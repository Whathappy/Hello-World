// lianzhan.cpp : 定义控制台应用程序的入口点。
//进行函数设计过程首先明确，该函数是否需要返回值，如需要则用return；函数所调用的变量值是否在函数过程中发生改变，如改变则变量应为引用型变量也就是将变量地址赋值给函数
#include "stdafx.h"
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
typedef struct Datatype{
int data;
Datatype *front;
}Datatype,*Ldatatype;
Ldatatype init(){
Datatype *ld=(Datatype*)malloc(sizeof(Datatype));
ld->front=NULL;   //注意初始化问题，对于需要访问使用的变量一定要初始化。
return ld;
//ld->front=NULL;
}
void pushelem(Datatype **ld,int e){
Datatype *p=(Datatype*)malloc(sizeof(Datatype));
p->front=*ld;
(*ld)->data=e;
(*ld)=p;
//ld=(Datatype*)malloc(sizeof(Datatype));
}
void popelem(Datatype **ld,int *e){  //使用引用型变量对实参进行更正，如要修改某变量值推荐使用带同种类型返回值的函数
if((*ld)->front){

(*ld)=(*ld)->front;
*e=(*ld)->data;}
else
printf("The stack is null");

}
void main(){
int e=0;
Ldatatype ld;
ld=init();
pushelem(&ld,1);
pushelem(&ld,2);
pushelem(&ld,3);
//printf("%i",ld->data);
for(int i=0;i<4;i++)
popelem(&ld,&e);
}

// paixu.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<math.h>
#include<stdlib.h>
#include<time.h>
typedef struct paixu1{
int data;
paixu1 *next;
}*Lpaixu;
void swap(int a,int b){
int temp=0;
temp=a;
a=b;
b=temp;

}
void zhijie_paixu(int a[],int n){
int temp;
for(int j=1;j<n;j++){
for(int i=0;i<j;i++){
if(a[i]>a[j]){
temp=a[i];
a[i]=a[j];
a[j]=temp;
}

}

}
}
void zheban_paixu(int a[],int n){
int low=0;
int m,temp;
int t;
int high;
for(int i=1;i<n;i++){
low=0;
high=i-1;
while(low<=high){
m=(low+high)/2;
if(a[m]<a[i])
low=m+1;
else
high=m-1;
}
if(a[i]<a[m]){   //待插入值比确定
temp=a[i];
for(int j=i;j>m;j--)
a[j]=a[j-1];
a[m]=temp;
}
else{
temp=a[i];
for(int j=i;j>m+1;j--)
a[j]=a[j-1];
a[m+1]=temp;
}
t=i;
printf("第%itang paixu d jieguo:",t);
for(int j=0;j<=t;j++){
printf("%i",a[j]);

}
printf("\n");
}
}
void sift(int a[],int low,int high){         //a[]数组从1开始存储数据元素,此函数作用在于选择当前树中的最大值使其作为整个树的根节点存在
int i=low;
int j=2*i;
int temp;
while(j<=high){
if(j<high&&a[j]<a[j+1]){
j=j+1;
}
if(a[i]<a[j]){
temp=a[i];             //此步骤从更优性能考虑可以进行替换比如设置temp值固定存储待确定位置的点a[i]；之后算法仅需用a[i]=a[j]代替替换语句。在完成while循环后
a[i]=a[j];             //将已经确定好的temp值赋值给a[i]即可
a[j]=temp; 
i=j;                   //需要继续向下进行的原因：在进行初次堆排序之后确定了最大值同时要将最大值与数组中最后一个元素置换，置换后堆排序位置打乱。
j=2*j;                 //但此时无需对所有非叶子结点进行堆排序仅需要对新置换后的结点堆排序即可。即找到新的a[1]在完全二叉树中的位置。
}
else
break;
}
}
void dui_pai(int a[],int n){
int temp1;
for(int i=n/2;i>=1;i--){ //从第一个非叶子节点也就是n/2的向下取整开始，使其子节点一定小于父母节点。
sift(a,i,n);
}
for(int i=n;i>=2;i--){
temp1=a[1];
a[1]=a[i];
a[i]=temp1;
sift(a,1,i-1);
//printf("the %i paixu max value is %i\n",i,a[1]);
}
}
void main(){
int a[10]={10,9,8,17,6,5,4,3,2,1};
/*for(int i=0;i<10;i++){
a[i]=rand()%100;
}*/
srand(time(0));
for(int m=0;m<10;m++){
a[m]=rand()%100;
}
zheban_paixu(a,10);
for(int i=0;i<10;i++){
printf("%i\n",a[i]);
}
int b[1001];
for(int m=1;m<=1000;m++){
b[m]=rand()%10000;
}
b[0]=0;
dui_pai(b,10);
for(int i=1;i<=10;i++){
printf("%i\n",b[i]);
}
}
